package executor

import (
	exec "github.com/verizonlabs/mesos-go/executor"
	"github.com/verizonlabs/mesos-go/executor/events"
	"log"
)

// Default executor
func NewExecutorHandler() *events.Mux {
	execHandler := ExecutorHandler{}
	execHandler.Subscribed(defaultSubscribeHandler())
	execHandler.Launch(defaultLaunchHandler())
	execHandler.Kill(defaultKillHandler())
	execHandler.Acknowledged(defaultAcknowledgeHandler())
	execHandler.Message(defaultMessageHandler())
	execHandler.Shutdown(defaultShutdownHandler())
	execHandler.Error(defaultErrorHandler())

	return &execHandler.mux
}

// If we have custom executor handlers.
func NewExecutorHandlerWithConfig(execHandler ExecutorHandler) *events.Mux {
	// Mux will already be populated by custom handlers, just return a pointer to the Mux Router
	return &execHandler.mux
}

/*
This is the first step in the communication process between the executor and agent.
This is also to be considered as subscription to the “/executor” events stream.
To subscribe with the agent, the executor sends a HTTP POST request with encoded SUBSCRIBE message.
The HTTP response is a stream with RecordIO encoding, with the first event being SUBSCRIBED event.
*/
func defaultSubscribeHandler() func() {
	return func(e *exec.Event) error {
		log.Print("Executor has subscribed.")
		return nil
	}
}

/*
Sent by the agent whenever it needs to assign a new task to the executor.
*/
func defaultLaunchHandler() func() {
	return func(e *exec.Event) error {
		log.Print("Executor is Launching.")
		return nil
	}
}

/*
The KILL event is sent whenever the scheduler needs to stop execution of a specific task.
The executor is required to send a terminal update (e.g., TASK_FINISHED, TASK_KILLED or TASK_FAILED) back to the agent
once it has stopped/killed the task. Mesos will mark the task resources as freed once the terminal update is received.
*/
func defaultKillHandler() func() {
	return func(e *exec.Event) error {
		log.Print("Executor is killing a task.")
		return nil
	}
}

/*
Sent by the agent in order to signal the executor that a status update was received as part of the reliable message
passing mechanism. Acknowledged updates must not be retried.
*/
func defaultAcknowledgeHandler() func() {
	return func(e *exec.Event) error {
		log.Print("Executor is Acknowledging.")
		return nil
	}
}

/*
Custom message generated by the scheduler and forwarded all the way to the executor. These messages are delivered
“as-is” by Mesos and have no delivery guarantees. It is up to the scheduler to retry if a message is dropped for
any reason. Note that data is raw bytes encoded as Base64.
*/
func defaultMessageHandler() func() {
	return func(e *exec.Event) error {
		log.Print("Executor is Launching.")
		return nil
	}
}

/*
Sent by the agent in order to shutdown the executor. Once an executor gets a SHUTDOWN event it is required to kill all
its tasks, send TASK_KILLED updates and gracefully exit. If an executor doesn’t terminate within a certain period
MESOS_EXECUTOR_SHUTDOWN_GRACE_PERIOD (an environment variable set by the agent upon executor startup), the agent will
forcefully destroy the container where the executor is running. The agent would then send TASK_LOST updates for any
remaining active tasks of this executor.
*/
func defaultShutdownHandler() func() {
	return func(e *exec.Event) error {
		log.Print("Executor is Launching.")
		return nil
	}
}

/*
Sent by the agent when an asynchronous error event is generated. It is recommended that the executor abort when it
receives an error event and retry subscription.
*/
func defaultErrorHandler() func() {
	return func(e *exec.Event) error {
		log.Print("Executor is Launching.")
		return nil
	}
}

/*
This behavior is common to any type of executor, we should allow any framework writers the flexibility of how
they'd like to handle events.
*/
type IExecutorHandler interface {
	Subscribed(events.HandlerFunc) error
	Launch(events.HandlerFunc) error
	Kill(events.HandlerFunc) error
	Acknowledged(events.HandlerFunc) error
	Message(events.HandlerFunc) error
	Shutdown(events.HandlerFunc) error
	Error(events.HandlerFunc) error
}

// Function pointer
type eventHandler func(int32, events.HandlerFunc) error

// Used to add a handler to Mux.
func addHandler(event int32, handlerFunc events.HandlerFunc) error {
	err := events.Handle(event, handlerFunc)
	if err != nil {
		return err
	}
	return nil
}

type ExecutorHandler struct {
	mux events.Mux
}

func (e *ExecutorHandler) Subscribed(handlerFunc events.HandlerFunc) error {
	return addHandler(exec.Event_SUBSCRIBED, handlerFunc)
}

func (e *ExecutorHandler) Launch(handlerFunc events.HandlerFunc) error {
	return addHandler(exec.Event_LAUNCH, handlerFunc)
}

func (e *ExecutorHandler) Kill(handlerFunc events.HandlerFunc) error {
	return addHandler(exec.Event_KILL, handlerFunc)
}

func (e *ExecutorHandler) Acknowledged(handlerFunc events.HandlerFunc) error {
	return addHandler(exec.Event_ACKNOWLEDGED, handlerFunc)
}

func (e *ExecutorHandler) Message(handlerFunc events.HandlerFunc) error {
	return addHandler(exec.Event_MESSAGE, handlerFunc)
}

func (e *ExecutorHandler) Shutdown(handlerFunc events.HandlerFunc) error {
	return addHandler(exec.Event_SHUTDOWN, handlerFunc)
}

func (e *ExecutorHandler) Error(handlerFunc events.HandlerFunc) error {
	return addHandler(exec.Event_ERROR, handlerFunc)
}
